Problem statement 1. Consider following Bank database schema and solve given queries:


Account(Acc_no, branch_name,balance) branch(branch_name,branch_city, assets) customer(cust_name,cust_street,cust_city) Depositor(cust_name,acc_no)
Loan(loan_no,branch_name,amount) Borrower(cust_name,loan_no)

Q.1 Create above tables with appropriate constraints like primary key, foreign key, not null etc.
with suitable data


SQL> create table branch(branch_name char(20) primary key,branch_city char(20) , assets number);


Table created.


SQL> insert into branch values('Nigdi','Pune',10000000)


SQL> insert into branch values('Akurdi','Pune',50000000); SQL> insert into branch values('Khed','Pune',70000000);
SQL> insert into branch values('Chinchwad','Pune',80000000); SQL> insert into branch values('Wafgaon','Khed',30000000);
SQL> select * from branch;


BRANCH_NAME	BRANCH_CITY	ASSETS


Nigdi	Pune	10000000
Akurdi	Pune	50000000
 
Khed	Pune	70000000
Chinchwad	Pune	80000000
Wafgaon	Khed	30000000


SQL> create table account(acc_no number primary key , branch_name char(20) references branch(branch_name) on delete set null ,balance number);


Table created.


SQL> insert into account values(1234567891,'Nigdi',10000); SQL> insert into account values(1234567892,'Nigdi',20000); SQL> insert into account values(1234567893,'Khed',30000);
SQL> insert into account values(1234567894,'Chinchwad',40000); SQL> select * from account;

ACC_NO BRANCH_NAME	BALANCE


1234567891 Nigdi	10000
1234567892 Nigdi	20000
1234567893 Khed	30000
1234567894 Chinchwad	40000 SQL> create table customer(cust_name char(20) primary key,cust_street varchar(30),cust_city char(20) );


Table created.


SQL> insert into customer values(‘Harshad’,'khed','Pune'); SQL> insert into customer values('Aviraj','Nigdi11','Pune'); SQL> insert into customer values('Nayan','Nigdi12','Pune');
SQL> insert into customer values('Ashirwad','Nigdi13','Pandharpur'); SQL> insert into customer values('Aditesh','audh','Pune');
 
SQL> insert into customer values('Vedant','Khed','Pune'); SQL> insert into customer values('Aditya','Khed','Pune');
SQL> insert into customer values('Siddhesh','Kolhapur','Kolhapur'); SQL> insert into customer values('Rushi','Kolhapur','Kolhapur');
SQL> insert into customer values('Sarang','Satara','Satara'); SQL> select * from customer;

CUST_NAME	CUST_STREET	CUST_CITY


Harshad	Khed	Pune
Aviraj	Nigdi11	Pune
Nayan	Nigdi12	Pune
Ashirwad	Nigdi13	Pandharpur
Aditesh	audh	Pune
Vedant	Khed	Pune
Aditya	Khed	Pune
Siddhesh	Kolhapur	Kolhapur
Rushi	Kolhapur	Kolhapur
Sarang	Satara	Satara


10 rows selected.


SQL> create table depositor(cust_name char(20) references customer(cust_name) on delete cascade , acc_no number references account(acc_no) on delete set null);


Table created.
SQL> select * from depositor;


CUST_NAME	ACC_NO

 
Harshad	1234567891
Aviraj	1234567892
Nayan	1234567893
Ashirwad	1234567894


SQL> create table loan(loan_no number primary key,branch_name char(20) references branch(branch_name) on delete set null , amount number);


Table created.

SQL> select * from loan;


LOAN_NO BRANCH_NAME	AMOUNT


9874563211 Nigdi	200000
9874563212 Nigdi	300000
9874563213 Nigdi	400000
9874563214 Khed	350000
9874563215 Chinchwad	250000


SQL> create table borrower(customer_name char(20) references customer(cust_name)on delete cascade,loan_no number references loan(loan_no) on delete set null);


Table created.


SQL> select * from borrower;


CUSTOMER_NAME	LOAN_NO


Aditesh	9874563211
Vedant	9874563212
 
Aditya	9874563213
Rushi	9874563214


Q.2. Create synonym for customer table as cust.
SQL> create synonym cust for customer;


Synonym created.
Q.3 Add customer phone number in Customer table.
SQL> alter table customer add phone_no number(10);


Table altered.
Q.4 Delete phone number attribute from Customer table.
SQL> alter table customer drop column phone_no;


Table altered.
SQL> desc customer;
Name	Null?	Type


CUST_NAME	NOT NULL CHAR(20)
CUST_STREET	VARCHAR2(30)
CUST_CITY	CHAR(20)
Q.5.	Find the names of all branches in loan relation.
SQL> select distinct branch_name from loan;


BRANCH_NAME


Nigdi Khed
Chinchwad
 
Q.6.	Find all customers who have a loan from bank. Find their names,loan_no and loan amount.
SQL> select borrower.customer_name , borrower.loan_no , loan.amount from borrower,loan where borrower.loan_no = loan.loan_no;


CUSTOMER_NAME	LOAN_NO	AMOUNT


Aditesh	9874563211	200000
Vedant	9874563212	300000
Aditya	9874563213	400000
Rushi	9874563214	350000
Q.7.	List all customers in alphabetical order who have loan from Nigdi branch.
SQL> select customer_name from borrower where loan_no in (select loan_no from loan where branch_name = 'Nigdi') order by customer_name;


CUSTOMER_NAME


Aditesh Aditya Vedant
Q.8.	Find all customers who have an account or loan or both at bank.
SQL> SELECT cust_name FROM customer where cust_name IN(SELECT customer_name FROM borrower INTERSECT SELECT cust_name FROM depositor);


CUST_NAME


Rushi
Q.9.	Find average account balance at Nigdi branch.
SQL> SELECT AVG(balance) AS avg_balance FROM account WHERE branch_name = 'Nigdi';
 
AVG_BALANCE


15000
Q.10.	Find no. of depositors at each branch.
SELECT branch_name, COUNT(*) AS num_depositors FROM depositor GROUP BY branch_name;
Q.11.	Delete all tuples at every branch located in Nigdi. DELETE FROM branch WHERE branch_city = 'Nigdi'; DELETE FROM account WHERE branch_name = 'Nigdi';













Problem statement 2.
a)	Consider following database schema and solve given queries


cust_mstr(cust_no,fname,lname)
add_dets(code_no,add1,add2,state,city,pincode)
1.	Create above Tables with suitable data
2.	Retrieve the address of customer Fname as 'xyz' and Lname as 'pqr'
3.	Create View on add_dets table by selecting any two columns and perform insert update delete operations

SQL> CREATE TABLE cust_mstr (
2	cust_no INT PRIMARY KEY,
3	fname VARCHAR(50),
 
4	lname VARCHAR(50)
5 );


Table created.


SQL> select * from cust_mstr;


CUST_NO FNAME LNAME


1	Harshad Karale
2	Rushikesh Magadum
3	Sarang Kadam


SQL> CREATE TABLE add_dets (code_no INT references cust_mstr(cust_no),add1 VARCHAR(100),add2 VARCHAR(100),state VARCHAR(50),city VARCHAR(50),pincode VARCHAR(10));


Table created.


SQL> INSERT INTO add_dets values(1,'Jaulke BK','Pargaon','Maharashtra','Khed',410512);


1 row created.


SQL> INSERT INTO add_dets values(2,'xyz','Kolhapur','Maharashtra','Kolhapur',410512);


1 row created


SQL> select * from add_dets where code_no IN ( select cust_no from cust_mstr where fname='Harshad' AND lname='Karale');
 
1
Jaulke BK Pargaon
Maharashtra Khed 410512
b)	Create following Tables
emp_mstr(e_mpno,f_name,l_name,m_name,dept,desg,branch_no) branch_mstr(name,b_no)
List the employee details along with branch names to which they belong
SQL> CREATE TABLE branch_mstr(name char(10),b_no number primary key);


Table created.
SQL> select * from branch_mstr; NAME B_NO


Computer 1
MECH 2
IT 3
Civil 4
SQL> CREATE TABLE emp_mstr(emp_no number NOT NULL,fname char(10),lname char(10),mname char(10),dept char(10),desg char(10),branch_no number references branch_mstr(b_no) on delete set null);
Table created.
SQL> select * from emp_mstr;
EMP_NO FNAME LNAME MNAME DEPT DESG BRANCH_NO


1 Harshad Karale Sanjay Comp Student 1
 
SQL> select * from emp_mstr where branch_no IN(select b_no from branch_mstr where name = 'Computer');
EMP_NO FNAME LNAME MNAME DEPT DESG BRANCH_NO


1 Harshad Karale Sanjay Comp Student 1
Problem statement 3. Consider following Bank database schema and solve given queries:


Account(Acc_no, branch_name,balance) branch(branch_name,branch_city, assets) customer(cust_name,cust_street,cust_city) Depositor(cust_name,acc_no)
Loan(loan_no,branch_name,amount) Borrower(cust_name,loan_no)

Q.1 Create above tables with appropriate constraints like primary key, foreign key constrains, not
null etc. with suitable data
Q.2.	Modify “assets” attribute of branch table to “Property”
SQL> ALTER TABLE branch RENAME COLUMN assets TO property;


Table altered.
Q.3.	Find all loan numbers for loans made at Akurdi Branch with loan amount > 12000.
SQL> SELECT loan_no FROM loan WHERE branch_name = 'Nigdi' AND amount > 12000;


LOAN_NO


9874563211
9874563212
9874563213
Q.4.	Find all customers who have both account and loan at bank.
 
SQL> SELECT cust_name FROM customer where cust_name IN(SELECT customer_name FROM borrower INTERSECT SELECT cust_name FROM depositor);


CUST_NAME


Rushi
Q.5.	Find all customer who have account but no loan at the bank.
SQL> SELECT cust_name FROM customer where cust_name IN(SELECT customer_name FROM borrower MINUS SELECT cust_name FROM depositor);

CUST_NAME


Aviraj Rushi
Q.6.	Find the average account balance at each branch
SQL> SELECT branch_name,AVG(balance) AS avg_balance FROM account Group by branch_name;


BRANCH_NAME	AVG_BALANCE


Nigdi	15000
Khed	30000
Chinchwad	40000
Q.7.	Find the branches where average account balance > 12000.
Q11. Find the branches where average account balance > 12000.
SQL> SELECT AVG(balance),branch_name FROM account GROUP BY branch_name HAVING AVG(balance)>20000;

AVG(BALANCE) BRANCH_NAME
 
 

30000 Khed
40000 Chinchwad
Q.8.	Find number of tuples in customer relation.
SQL> SELECT COUNT(*) AS tuple_no FROM customer;


TUPLE_NO


12
Q.9.	Calculate total loan amount given by bank.
SQL> SELECT SUM(amount) AS total_loan FROM loan; TOTAL_LOAN


2143800
Q.10.	Delete all loans with loan amount between 1300 and 1500.
SQL> DELETE FROM loan WHERE amount BETWEEN 25000 AND 30000;


1 row deleted.
Q.11.	Create sequence roll_seq and use in student table for roll_no column.
SQL> CREATE SEQUENCE roll_no START with 1 INCREMENT BY 1 MINVALUE 1 MAXVALUE 100 CYCLE;

Sequence created.


SQL> CREATE TABLE student(rollno number , name varchar(10));


Table created.
SQL> select * from student;
 
ROLLNO NAME


1	Harshad
2	Nayan
3	Aviraj



Problem statement 4.
a)	Create following Tables with suitable data and solve following query


cust_mstr(custno,fname,lname) acc_fd_cust_dets(codeno,acc_fd_no) fd_dets(fd_sr_no,amt)
List the customer holding fixed deposit of amount more than 5000
SQL> CREATE TABLE fd_dets(fd_sr_no number primary key ,amt number); Table created.
SQL> select * from cust_mstr; CUST_NO FNAME LNAME


1 Harshad Karale
2 Aviraj Kale
3 Nayan Keote
SQL> select * from fd_dets; FD_SR_NO AMT


1 2000
2 6000
3 8000
4 10000
 
SQL> CREATE TABLE acc_fd_cust_dets(codeno number references cust_mstr(cust_no) on delete cascade,acc_fd_no number references fd_dets(fd_sr_no) on delete cascade);
Table created.
SQL> select * from acc_fd_cust_dets; CODENO ACC_FD_NO


1 1
2 2
3 3


SQL> select * from cust_mstr where cust_no IN(SELECT codeno from acc_fd_cust_dets where acc_fd_no IN(SELECT fd_sr_no FROM fd_dets where amt>5000));
CUST_NO FNAME LNAME


2 Aviraj Kale
3 Nayan Keote
b)	Create view on cust_mstr and acc_fd_cust_dets tables by selecting any one column from each table perform insert update delete operations
1.	Create a view selecting any one column from each table:
CREATE VIEW cust_acc_view AS SELECT c.cust_name, a.acc_no FROM cust_mstr c JOIN acc_fd_cust_dets a ON c.cust_no = a.cust_no;
2.	Perform insert operation on the view:
INSERT INTO cust_acc_view (cust_name, acc_no) VALUES ('John Doe', 123456);
3.	Perform update operation on the view:
UPDATE cust_acc_view SET acc_no = 654321 WHERE cust_name = 'John Doe';
4.	Perform delete operation on the view:
DELETE FROM cust_acc_view WHERE cust_name = 'John Doe';
c)	Create following Tables with suitable data and solve following query emp_mstr(emp_no,f_name,l_name,m_name,dept)
 
cntc_dets(code_no,cntc_type,cntc_data)
List the employee details along with contact details using left outer join & right join
SQL> CREATE TABLE branch_mstr(name char(10),b_no number primary key);


Table created.
SQL> select * from branch_mstr; NAME B_NO


Computer 1
MECH 2
IT 3
Civil 4
SQL> CREATE TABLE emp_mstr(emp_no number NOT NULL,fname char(10),lname char(10),mname char(10),dept char(10),desg char(10),branch_no number references branch_mstr(b_no) on delete set null);
Table created.
SQL> select * from emp_mstr;
EMP_NO FNAME LNAME MNAME DEPT DESG BRANCH_NO


1 Harshad Karale Sanjay Comp Student 1


SQL> select * from emp_mstr where branch_no IN(select b_no from branch_mstr where name = 'Computer');
EMP_NO FNAME LNAME MNAME DEPT DESG BRANCH_NO


1 Harshad Karale Sanjay Comp Student 1
4.	Create following Tables emp_mstr(emp_no,f_name,l_name,m_name,dept) cntc_dets(code_no,cntc_type,cntc_data) List the employee details along with contact details using left outer join & right join
 
SQL> CREATE TABLE emp_mstr(emp_no number primary key,fname char(10),lname char(10),mname char(10),dept char(10));
Table created.
SQL> select * from emp_mstr;
EMP_NO FNAME LNAME MNAME DEPT




1	Harshad Karale Sanjay Comp
2	Aviraj Kale Popat IT
3	Nayan Keote Gajanan AIML
4	Ashirwad Katakamwar Rajeshwar Entc
5	Rushi Magadum Ranjit Comp
SQL> CREATE TABLE cntc_dets(codeno number references
emp_mstr(emp_no),cntc_type varchar(20),cntc_data varchar(20)); Table created.
SQL> select * from cntc_dets; CODENO CNTC_TYPE CNTC_DATA


1	Email harshad@gmail.com
2	Mob 9322918702
3	Email nayan@gmail.com
3 mob 1234567890 LEFT OUTER JOIN:
SQL> select * from emp_mstr LEFT OUTER JOIN cntc_dets ON emp_mstr.emp_no = cntc_dets.codeno;
EMP_NO FNAME LNAME MNAME DEPT CODENO


1	Harshad Karale Sanjay Comp 1
 
2	Aviraj Kale Popat IT 2
3	Nayan Keote Gajanan AIML 3
4	Ashirwad Katakamwar Rajeshwar Entc
5	Rushi Magadum Ranjit Comp CNTC_TYPE CNTC_DATA


Email harshad@gmail.com Mob 9322918702
Email nayan@gmail.com RIGHT OUTER JOIN
SQL> select * from emp_mstr RIGHT OUTER JOIN cntc_dets ON emp_mstr.emp_no = cntc_dets.codeno;
EMP_NO FNAME LNAME MNAME DEPT CODENO




CNTC_TYPE CNTC_DATA


1 Harshad Karale Sanjay Comp 1 Email harshad@gmail.com
2 Aviraj Kale Popat IT 2
Mob 9322918702
3 Nayan Keote Gajanan AIML 3 Email nayan@gmail.com
3 Nayan Keote Gajanan AIML 3
mob 1234567890
5. Create following Tables cust_mstr(cust_no,fname,lname) add_dets(code_no,pincode) List the customer who do not have bank branches in their vicinity.
SQL> CREATE TABLE cust_mstr(cust_no varchar(10) primary key ,fname char(10),lname char(10));
 
Table created.
SQL> select * from cust_mstr; CUST_NO FNAME LNAME


C1 Harshad Karale C2 Aviraj Kale
C3 Nayan Keote
SQL> select * from add_dets;
SQL> CREATE TABLE add_dets(codeno varchar(10),pincode number); Table created.
CODENO PINCODE


B1 410510
C1 410510
C2 410511
C3 410512
SQL> select * from cust_mstr where cust_no IN(select codeno from add_dets where codeno like 'C%' AND pincode NOT IN(select pincode from add_dets where codeno like 'B%'));
CUST_NO FNAME LNAME


C2 Aviraj Kale C3 Nayan Keote

Problem statement 5.
a)	Consider following database schema and solve given queries


cust_mstr(cust_no,fname,lname)
add_dets(code_no,add1,add2,state,city,pincode)
 
1.	Create above Tables with suitable data
2.	Retrieve the address of customer Fname as 'xyz' and Lname as 'pqr'
3.	Create View on add_dets table by selecting any two columns and perform insert update delete operations
b)	Create following Tables


cust_mstr(cust_no,fname,lname) add_dets(code_no,pincode)

(Most of the queries are similar as follow)


List the customer who do not have bank branches in their vicinity.


Problem statement 6.
Q 1.Consider table Stud(Roll, Att,Status)
Write a PL/SQL block for following requirement and handle the exceptions.
Roll no. of student will be entered by user. Attendance of roll no. entered by user will be checked in
Stud table. If attendance is less than 75% then display the message “Term not granted” and set the
status in stud table as “D”. Otherwise display message “Term granted” and set the status in stud
table as “ND”.



SQL> CREATE TABLE stud(roll_no NUMBER PRIMARY KEY , att NUMBER ,status char(5)); Table created.
SQL> select * from stud; ROLL_NO ATT STATU
 
 

123 95 NULL
129 99 NULL
133 94 NULL
137 97 NULL
300 60 NULL
301 70 NULL
Declare
mroll number(10); matt number(10); Begin mroll:=&mroll;
select att into matt from stud where roll_no = mroll; if matt<75 then
dbms_output.put_line(mroll || 'is detained'); update stud set status='D' where roll_no = mroll; else
dbms_output.put_line(mroll || 'is not detained'); update stud set status='ND' where roll_no = mroll; end if;
Exception
when no_data_found then dbms_output.put_line(mroll || 'Not found');

End;
/
SQL> select * from stud; ROLL_NO ATT STATU

 
123 95 ND
129 99 ND
133 94 ND
137 97 ND
300 60 D
301 70 D
6	rows selected.


Q 2.The bank manager has decided to activate all those accounts which were previously marked as
inactive for performing no transaction in last 365 days. Write a PL/SQ block (using implicit cursor)
to update the status of account, display an approximate message based on the no. of rows affected
by the update. (Use of %FOUND, %NOTFOUND, %ROWCOUNT)


SELECT * FROM account; ACC_NO NAME STATUS


129 Harshad active
123 Avi inactive
122 Aadi inactive
137 Nayan active
4 rows selected. BEGIN
UPDATE account SET status = 'active' WHERE status = 'inactive'; dbms_output.put_line(SQL%ROWCOUNT||' no of account updated'); END;
/
2 no of account updated
 
PL/SQL procedure successfully completed. SELECT * FROM account;
ACC_NO NAME STATUS


129 Harshad active
123 Avi active
122 Aadi active
137 Nayan active
4 rows selected.


BEGIN
UPDATE account SET status = 'active' WHERE status = 'inactive'; dbms_output.put_line(SQL%ROWCOUNT||' no of account updated'); END;
/
0 no of account updated


Problem statement 7.
Q 1. Write an SQL code block these raise a user defined exception where business rule is voilated.
BR for client_master table specifies when the value of bal_due field is less than 0 handle the
exception.


Declare
input number(10); client_id number; bal_due Exception;
Begin
client_id :=& client_id;
 
input :=&input; IF input < 0 THEN raise bal_due; ELSE
INSERT INTO client_master VALUES(client_id,input); dbms_output.put_line('Inserted successfully');
END IF;
Exception
when bal_due then
dbms_output.put_line(input || 'Your balance is less then 0'); End;

Enter value for client_id: 3 old 6: client_id :=& client_id; new 6: client_id :=3;
Enter value for input: -10 old 7: input :=&input;
new 7: input :=-10;
-10
Your balance is less then 0


Enter value for client_id: 2 old 6: client_id :=& client_id;

new 6: client_id :=2;
Enter value for input: 100 old 7: input :=&input;
new 7: input :=100; Inserted successfully
 
Q 2. Organization has decided to increase the salary of employees by 10% of existing salary, who
are having salary less than average salary of organization, Whenever such salary updates takes
place, a record for the same is maintained in the increment_salary table. EMP (E_no , Salary)
increment_salary(E_no , Salary)
SELECT * FROM salary; EMP_NO SALARY


129 11000
123 22000
137 30000


DECLARE
CURSOR salhigh IS SELECT emp_no,salary FROM salary WHERE salary < (SELECT AVG(salary) FROM salary);
memp_no salary.emp_no%type; msalary salary.salary%type; BEGIN
OPEN salhigh;
IF salhigh%isopen THEN LOOP
fetch salhigh into memp_no,msalary; exit when salhigh%notfound;
if salhigh%found then
update salary set salary = (0.1*msalary+ msalary) WHERE emp_no = memp_no; insert into increment_salary values(memp_no,0.1*msalary+ msalary);
 
end if; end loop; end if;
Close salhigh; END;
/
PL/SQL procedure successfully completed.


SELECT * FROM salary; EMP_NO SALARY


129 12100
123 24200
137 33000
SELECT * FROM increment_salary; EMP_NO INCREMENT_SALARY


121 12100
122 24200
129 33000


Problem statement 8.
Q 1.Borrower(Roll_no, Name, DateofIssue, NameofBook, Status) Fine(Roll_no,Date,Amt)
1.	Accept roll_no& name of book from user.
2.	Check the number of days (from date of issue), if days are between 15 to 30 then fine amount
will be Rs 5per day.
3.	If no. of days>30, per day fine will be Rs 50 per day & for days less than 30, Rs. 5 per day. After submitting the book, status will change from I to R
 
4.	If condition of fine is true, then details will be stored into fine table.
5.	Also handles the exception by named exception handler or user define exception handler.
CREATE PROCEDURE process_borrower_fine ( mroll_no IN NUMBER
) IS
days INTEGER; doi DATE;
dor DATE := SYSDATE;
mamt NUMBER;
BEGIN
SELECT dateofissue INTO doi FROM borrower WHERE roll_no = mroll_no; days := dor - doi;
dbms_output.put_line(days);
UPDATE borrower SET status = 'r' WHERE roll_no = mroll_no;
IF (days > 30) THEN
mamt := (days - 30) * 50 + 75;
INSERT INTO fine VALUES (mroll_no, dor, mamt);
ELSIF (days > 15) THEN


mamt := (days - 15) * 5;
INSERT INTO fine VALUES (mroll_no, dor, mamt); END IF;
END;
SQL> BEGIN
2 process_borrower_fine(&mroll_no);
3 END;
4 /
SQL> select * from fine;
 
ROLL_NO DATEOFRET AMT


3 16-FEB-24 40
4 16-FEB-24 150
2 16-FEB-24 5
3 16-FEB-24 40
4 rows selected.



Problem statement 9.
Q 1. Write PL/SQL block using explicit cursor for following requirements:
College has decided to mark all those students detained (D) who are having attendance less than
75%.
Whenever such update takes place, a record for the same is maintained in the D_Stud table.
create table stud21(roll number(4), att number(4), status varchar(1)); create table d_stud(roll number(4), att number(4));
SELECT * FROM stud; ROLL_NO ATT S
-
129 90
137 74


123 50
DECLARE
CURSOR check_status IS SELECT roll_no,att FROM stud WHERE att < 75 ; mroll_no stud.roll_no%type;
matt stud.att%type;
BEGIN
 
OPEN check_status;
IF check_status%isopen THEN LOOP
FETCH check_status INTO mroll_no,matt; exit WHEN check_status%notfound;
IF check_status%found THEN
UPDATE stud SET status = 'D' WHERE roll_no = mroll_no; INSERT INTO d_stud VALUES(mroll_no,matt);
END IF;
END LOOP;
END IF;
CLOSE check_status; END;
/
PL/SQL procedure successfully completed.


SELECT * FROM stud;


ROLL_NO ATT S
-
129 90
137 74 D
123 50 D
SELECT * FROM d_stud;


ROLL_NO ATT


137 74
123 50
 

Problem statement 10.
Q 1.Consider table Stud(Roll, Att,Status)
Write a PL/SQL block for following requirement and handle the exceptions.
Roll no. of student will be entered by user. Attendance of roll no. entered by user will be checked in
Stud table. If attendance is less than 75% then display the message “Term not granted” and set the
status in stud table as “D”. Otherwise display message “Term granted” and set the status in stud
table as “ND”.
(Taken From ChatGPT)
DECLARE
v_roll_number Stud.Roll%TYPE; v_attendance Stud.Att%TYPE; v_status Stud.Status%TYPE;
BEGIN
-- Accepting roll number from user v_roll_number := &roll_number;

-- Retrieving attendance and status for the entered roll number SELECT Att, Status
INTO v_attendance, v_status FROM Stud
WHERE Roll = v_roll_number;


-- Checking attendance percentage and updating status accordingly IF v_attendance < 75 THEN
DBMS_OUTPUT.PUT_LINE('Term not granted');
 
UPDATE Stud SET Status = 'D'
WHERE Roll = v_roll_number; ELSE
DBMS_OUTPUT.PUT_LINE('Term granted'); UPDATE Stud
SET Status = 'ND'
WHERE Roll = v_roll_number; END IF;
EXCEPTION
WHEN NO_DATA_FOUND THEN
DBMS_OUTPUT.PUT_LINE('Roll number not found'); WHEN OTHERS THEN
DBMS_OUTPUT.PUT_LINE('An error occurred: ' || SQLERRM); END;
/


Q 2.Write a update, delete trigger on clientmstr table. The System should keep track of the records
that ARE BEING updated or deleted. The old value of updated or deleted records should be added
in audit_trade table. (separate implementation using both row and statement triggers)
CREATE OR REPLACE TRIGGER trade_record AFTER INSERT OR DELETE
ON client
FOR EACH ROW DECLARE
op VARCHAR(10); BEGIN
IF updating THEN
 
op:='update'; END IF;
IF deleting THEN op:='Delete'; END IF;
INSERT INTO trade VALUES(:old.c_id,:old.p_amt,op); END;
/
Trigger created.


SELECT * FROM client;
C_ID P_AMT


121 1500
122 1800
129 1500
124 1900
125 3000


SELECT * FROM trade; no rows selected
CREATE OR REPLACE TRIGGER trade_record AFTER UPDATE OR DELETE
ON client
FOR EACH ROW DECLARE
op VARCHAR(10); BEGIN
IF updating THEN
 
op:='update'; END IF;
IF deleting THEN op:='Delete'; END IF;
INSERT INTO trade VALUES(:old.c_id,:old.p_amt,op); END;
/
Trigger created.


SELECT * FROM client;
C_ID P_AMT


121 1500
122 1800
129 1500
124 1900
125 3000


SELECT * FROM trade; no rows selected
UPDATE client SET p_amt = 1000 WHERE p_amt=1500;


4 rows updated. SELECT * FROM trade; C_ID P_AMT STATUS


121 1500 update
129 1500 update
 
CREATE OR REPLACE TRIGGER trade_record AFTER UPDATE OR DELETE
ON client DECLARE
op VARCHAR(10); BEGIN
IF updating THEN op:='update'; END IF;
IF deleting THEN op:='Delete'; END IF;
INSERT INTO trade VALUES(:old.c_id,:old.p_amt,op); END;
CREATE TABLE trade_status(status VARCHAR(10)); Table created.

CREATE OR REPLACE TRIGGER trade_record AFTER UPDATE OR DELETE
ON client DECLARE
op VARCHAR(10); BEGIN
IF updating THEN op:='update'; END IF;
IF deleting THEN


op:='Delete';
 
END IF;
INSERT INTO trade_status VALUES(op); END;
/
Trigger created.
SELECT * FROM client;
C_ID P_AMT


121 1000
122 1000
129 1000
124 1000
125 3000


UPDATE client SET p_amt = 1500 WHERE p_amt=1000; 4 rows updated.
SELECT * FROM trade_status;


STATUS


Update



Problem statement 11.


Q 1. Write a stored function in PL/SQL for given requirement and use the same in PL/SQL block.
Account no. and branch name will be accepted from user. The same will be searched in table
 
acct_details. If status of account is active then display appropriate message and also store the
account details in active_acc_details table, otherwise display message on screen “account is
inactive”.


SQL> create table acc_details(acc_no NUMBER primary key , b_name char(10) , status char(2));
Table created.
SQL> SELECT * FROM acc_details; ACC_NO B_NAME ST


1	Nigdi A
2	Nigdi I
3	Nigdi A
4	Khed I
5	Khed I
CREATE OR REPLACE FUNCTION account_fun ( macc_no IN NUMBER,
b_name IN CHAR -- Removed size specification


) RETURN CHAR -- Removed size specification IS
mst CHAR(2); -- It's okay to specify sizes for internal variables BEGIN
SELECT status INTO mst FROM acc_details
WHERE acc_no = macc_no AND b_name = b_name; -- Use the parameter b_name RETURN mst;
EXCEPTION
WHEN NO_DATA_FOUND THEN
 
RETURN NULL; -- Return NULL if no data is found WHEN OTHERS THEN
RETURN NULL; -- General error handling END;
Function created.
DECLARE
macc_no NUMBER(10); mst CHAR(2);
b_name CHAR(10); -- Example value for b_name BEGIN
macc_no := &macc_no; b_name := '&b_name';
mst := account_fun(macc_no, b_name); -- Corrected function name and added b_name IF mst = 'A' THEN
DBMS_OUTPUT.PUT_LINE('Account is active'); -- Corrected quotes and added missing parenthesis
INSERT INTO active_acc_details VALUES(macc_no,b_name,mst); ELSE
DBMS_OUTPUT.PUT_LINE('Account is Inactive'); -- Corrected quotes and added missing parenthesis
END IF;
END;
SQL> select * from active_acc_details; ACC_NO B_NAME ST


1	1 A
1	1 A
3 Nigdi A


Enter value for macc_no: 2
 
old 6: macc_no := &macc_no; new 6: macc_no := 2;
Enter value for b_name: Nigdi old 7: b_name := '&b_name'; new 7: b_name := 'Nigdi'; Account is Inactive



Problem statement 12.


Q 1. Write an SQL code block these raise a user defined exception where business rule is voilated.
BR for client_master table specifies when the value of bal_due field is less than 0 handle the
exception.
Declare
input number(10); client_id number; bal_due Exception;
Begin
client_id :=& client_id; input :=&input;
IF input < 0 THEN raise bal_due; ELSE
INSERT INTO client_master VALUES(client_id,input); dbms_output.put_line('Inserted successfully');
END IF;
Exception
when bal_due then
 
dbms_output.put_line(input || 'Your balance is less then 0'); End;

Enter value for client_id: 3 old 6: client_id :=& client_id; new 6: client_id :=3;
Enter value for input: -10 old 7: input :=&input;
new 7: input :=-10;
-10
Your balance is less then 0


Enter value for client_id: 2 old 6: client_id :=& client_id;

new 6: client_id :=2;
Enter value for input: 100 old 7: input :=&input;
new 7: input :=100; Inserted successfully

Q 2.Write a before trigger for Insert, update event considering following requirement: Emp(e_no, e_name, salary)
I)	Trigger action should be initiated when salary is tried to be inserted is less than Rs. 50,000/-
II)	Trigger action should be initiated when salary is tried to be updated for value less than Rs.
50,000/-
Action should be rejection of update or Insert operation by displaying appropriate error message.
 
Also the new values expected to be inserted will be stored in new table. Tracking(e_no, salary).

SELECT * FROM employee; no rows selected
CREATE OR REPLACE TRIGGER emp_sal_record
2	BEFORE UPDATE OR INSERT
3	ON employee
4	FOR EACH ROW
5	DECLARE
6	sal NUMBER:=:new.salary;
7	BEGIN
8	IF sal < 50000 THEN
9	IF updating THEN
10	raise_application_error(-20003,'This update opration violet comapany rule / record not inserted');
11	END IF;
12	IF inserting THEN
13	raise_application_error(-20003,'This insert opration violet comapany rule / record not inserted');
14	END IF;
15	ELSE
16	DBMS_OUTPUT.PUT_LINE('Record created successfully');
17	INSERT INTO emp_sal VALUES(:new.e_no,:new.salary);
18	END IF;
19	END;
20	/
Trigger created.
INSERT INTO employee VALUES(129,'Aviraj',100000);
 
Record created successfully 1 row created.

INSERT INTO employee VALUES(124,'Ankit',1000); INSERT INTO employee VALUES(124,'Ankit',1000)
UPDATE employee SET salary = 1000 WHERE e_no =129;


Problem statement 13.
Q 1. . Write a PL/SQL stored Procedure for following requirements and call the procedure in appropriate
PL/SQL block.
Borrower(Rollin, Name, DateofIssue, NameofBook, Status) Fine(Roll_no,Date,Amt)
Accept roll_no& name of book from user.
1.	Check the number of days (from date of issue), if days are between 15 to 30 then fine amount
will be Rs 5per day.
2.	If no. of days>30, per day fine will be Rs 50 per day & for days less than 30, Rs. 5 per day.
3.	After submitting the book, status will change from I to R.
4.	If condition of fine is true, then details will be stored into fine table.
CREATE PROCEDURE process_borrower_fine ( mroll_no IN NUMBER
) IS
days INTEGER; doi DATE;
dor DATE := SYSDATE;
mamt NUMBER;
BEGIN
SELECT dateofissue INTO doi FROM borrower WHERE roll_no = mroll_no;
 
days := dor - doi; dbms_output.put_line(days);
UPDATE borrower SET status = 'r' WHERE roll_no = mroll_no;
IF (days > 30) THEN
mamt := (days - 30) * 50 + 75;
INSERT INTO fine VALUES (mroll_no, dor, mamt);
ELSIF (days > 15) THEN


mamt := (days - 15) * 5;
INSERT INTO fine VALUES (mroll_no, dor, mamt); END IF;
END;
SQL> BEGIN
2	process_borrower_fine(&mroll_no);
3	END;
4	/
SQL> select * from fine; ROLL_NO DATEOFRET AMT


3 16-FEB-24 40
4 16-FEB-24 150
2 16-FEB-24 5
3 16-FEB-24 40
4 rows selected.



Problem statement 14.
Q 1. Write a Stored Procedure namely proc_Grade for the categorization of student. If marks
 
scored by students in examination is <=1500 and marks>=990 then student will be placed in
distinction category if marks scored are between 989 and900 category is first class, if marks 899
and 825 category is Higher Second Class.
Write a PL/SQL block for using procedure created with above requirement. Stud_Marks(name, total_marks)
Result(Roll,Name, Class)
SQL> select * from stud_marks; ROLL_NO MARKS


1 1270
2 870
3 970


CREATE OR REPLACE PROCEDURE proc_Grade(
p_name IN VARCHAR2, p_marks IN NUMBER, p_roll IN NUMBER)
IS
v_class VARCHAR2(100); BEGIN
IF p_marks <= 1500 AND p_marks >= 990 THEN v_class := 'Dist';
ELSIF p_marks < 990 AND p_marks >= 900 THEN v_class := 'First';
ELSIF p_marks < 900 AND p_marks >= 825 THEN v_class := 'Higher';

ELSE
 
v_class := 'Other'; END IF;
INSERT INTO Result VALUES (p_roll, p_name, v_class); END;
DECLARE
v_name VARCHAR2(100); v_total_marks NUMBER; v_roll NUMBER;
BEGIN
v_roll := &v_roll;
v_name := '&v_name';
select marks INTO v_total_marks FROM stud_marks where roll_no = v_roll; proc_Grade(v_name, v_total_marks, v_roll);
END;
SQL> select * from Result; ROLL_NO NAME CLASS


1 Harshad Dist
2 Nayan Higher
3 Aviraj First



Problem statement 15. Create Database PCCOE Create following Collections
Teachers(Tname,dno,dname,experience,salary,date_of_joining ) Students(Sname,roll_no,class)
Q1. Find the information about all teachers
Q2. Find the information about all teachers of computer department
 
Q3. Find the information about all teachers of computer,IT,ande&TC department
Q4. Find the information about all teachers of computer,IT,and E&TC department having salary
greater than or equl to 10000/-
Q5. Find the student information having roll_no = 2 or Sname=xyz
Q6. Update the experience of teacher-praveen to 10years, if the entry is not available in database
consider the entry as new entry.
Q7. Update the deparment of all the teachers working in IT deprtment to COMP Q8. Find the teachers name and their experience from teachers collection
Q9. Using Save() method insert one entry in department collection Q10. Using Save() method change the dept of teacher praveen to IT
Q11. Delete all the doccuments from teachers collection having IT dept.
Q12. Display with pretty() method, the first 3 doccuments in teachers collection in ascending order.


Problem statements 16 Consider the relational database Supplier(Sid,Sname,address)
Parts(Pid, Pname, Color) Catalog(sid,pid,cost)
Q. Find name of all parts whose color is green.
SELECT Pname FROM Parts
WHERE Color = 'green';
Q. Find names of suppliers who supply some red parts.
SELECT DISTINCT Sname
FROM Supplier WHERE Sid IN ( SELECT Sid
 
FROM Catalog WHERE pid IN ( SELECT Pid
FROM Parts
WHERE Color = 'red'
)
);
Q. Find names of all parts whose cost is more than Rs25.
SELECT Pname FROM Parts WHERE Pid IN (
SELECT pid
FROM Catalog WHERE cost > 25
);



Consider the relational database Person(pname,street city)
Company(cname,city)
Manages(pname,mname)
Q. Find the street and city of all employees who work for “Idea”, live in Pune and earn more than 3000.
SELECT p.street, p.city FROM Person p
JOIN Manages m ON p.pname = m.pname JOIN Company c ON m.mname = c.cname
WHERE c.cname = 'Idea' AND p.city = 'Pune' AND p.pname IN ( SELECT pname
FROM Manages
 
GROUP BY pname
HAVING MIN(salary) > 3000
);



Consider the relational database Student(Rollno,name,address) Subject(sub_code,sub_name)
Marks(Rollno,sub_code, marks)
Q. Find out average marks of each student along with the name of student.
SELECT s.name, AVG(m.marks) AS average_marks FROM Student s JOIN Marks m ON s.Rollno
= m.Rollno GROUP BY s.Rollno, s.name;



Q. Find how many students have failed in the subject “DBMS”
SELECT COUNT(*) AS num_failed_students FROM Marks WHERE sub_code =SELECT sub_code FROM Subject WHERE sub_name = 'DBMS') AND marks < 40;





Problem statements 17
Write Pl/SQL code block that will accept account number from user , check if the users balance is less than
the minimum balance , only deduct Rs.100/- from the balance .
CREATE TABLE Account (Acc_no NUMBER PRIMARY KEY, branch_name VARCHAR2(50), balance NUMBER);


INSERT INTO Account (Acc_no, branch_name, balance)VALUES (1, 'Branch1', 1500); INSERT INTO Account (Acc_no, branch_name, balance)VALUES (2, 'Branch2', 2000); INSERT INTO Account (Acc_no, branch_name, balance)VALUES (3, 'Branch3', 100);
 
DECLARE
v_acc_no NUMBER; v_balance NUMBER;
v_min_balance NUMBER := 1000; -- Minimum balance required


BEGIN
-- Accepting account number from user v_acc_no := &acc_no;

-- Retrieving balance for the entered account number SELECT balance INTO v_balance
FROM Account
WHERE Acc_no = v_acc_no;


-- Checking if balance is less than minimum balance IF v_balance < v_min_balance THEN
UPDATE Account
SET balance = balance - 100 WHERE Acc_no = v_acc_no;
DBMS_OUTPUT.PUT_LINE('Deducted Rs.100 from the balance.'); ELSE
DBMS_OUTPUT.PUT_LINE('Balance is above minimum balance.'); END IF;

COMMIT; -- Committing the transaction EXCEPTION
WHEN NO_DATA_FOUND THEN
DBMS_OUTPUT.PUT_LINE('Account number not found.');
 
WHEN OTHERS THEN
DBMS_OUTPUT.PUT_LINE('An error occurred: ' || SQLERRM); ROLLBACK; -- Rolling back the transaction in case of error
END;
/





Problem statements 18
Write Pl/SQL code block for inverting number 1234 to 4321.
DECLARE
v_number NUMBER := 1234; -- Number to invert v_inverted_number NUMBER := 0;
v_remainder NUMBER;


BEGIN
WHILE v_number > 0 LOOP
v_remainder := MOD(v_number, 10);
v_inverted_number := v_inverted_number * 10 + v_remainder; v_number := (v_number - v_remainder) / 10;
END LOOP;


DBMS_OUTPUT.PUT_LINE('Inverted Number: ' || v_inverted_number); END;
/
 
Problem statements 19
The bank manager has decided to mark all those accounts as inactive (I) on which there are no
transactions performed in last 365 days. Whenever any such update takes place a record for the
same is maintained in the INACT_MASTER_TABLE comprising of the account number, the opening date and type of account. Write PL/SQL code block to do the same(cursor for
loop)
(We doesn’t have for loop cursor)


Problem statements 20
Write PL/SQL code block that will merge the data available in the newly created table
NEW_BRANCHES with the data available in the table BRANCH_MASTER. If the data in the first
table already exists in the second table then data should be skipped.(parameterized cursor)
(We doesn’t have parameterize cursor)


Problem statements 21
Write PL/SQL code block such that depending upon user supplied account number, the customer to
whom account belongs , the introducer of that account are inserted into ACCOUNT_MASTER_INFO table .If the user enters an account number that is not in the ACCOUNT_MASTER table, then the PL/SQL block must display appropriate error message(Exception Handling)

DECLARE
v_acc_no NUMBER := &account_number; -- User-supplied account number v_cust_name VARCHAR2(100);
v_introducer VARCHAR2(100);
 
BEGIN
SELECT cust_name, introducer INTO v_cust_name, v_introducer FROM ACCOUNT_MASTER
WHERE acc_no = v_acc_no;


INSERT INTO ACCOUNT_MASTER_INFO (acc_no, cust_name, introducer) VALUES (v_acc_no, v_cust_name, v_introducer);

DBMS_OUTPUT.PUT_LINE('Record inserted successfully.'); EXCEPTION
WHEN NO_DATA_FOUND THEN
DBMS_OUTPUT.PUT_LINE('Account number not found in ACCOUNT_MASTER table.'); WHEN OTHERS THEN
DBMS_OUTPUT.PUT_LINE('An error occurred: ' || SQLERRM); END;
/
Problem statements 22
A stored function is created to perform the ACCOUNT_NO check operation
.F_checkAccNO() is
the name of function which accept a variable ACCOUNT_NO and returns the value to host environment The value changes from 0(if ACCOUNT_NO does not exist) to 1(if
ACCOUNT_NO
exist) depending on the records retrieved.


CREATE OR REPLACE FUNCTION F_checkAccNO (p_account_no IN NUMBER) RETURN NUMBER
IS
v_count NUMBER;
BEGIN
 
-- Check if the account number exists in the table SELECT COUNT(*)
INTO v_count
FROM ACCOUNT_MASTER
WHERE acc_no = p_account_no;


-- Return 1 if account number exists, otherwise return 0 RETURN CASE WHEN v_count > 0 THEN 1 ELSE 0 END;
END;
/



DECLARE
v_result NUMBER;
BEGIN
v_result := F_checkAccNO(123456789); -- Replace 123456789 with the account number you want to check


IF v_result = 1 THEN
DBMS_OUTPUT.PUT_LINE('Account number exists.'); ELSE
DBMS_OUTPUT.PUT_LINE('Account number does not exist.'); END IF;
END;
/
 
Problem statements 23
create a row level trigger for the CUSTOMERS table that would fire for INSERT or UPDATE or DELETE
operations performed on the CUSTOMERS table. This trigger will display the salary difference between the old
values and new values



CREATE OR REPLACE TRIGGER customers_salary_trigger BEFORE INSERT OR UPDATE OR DELETE ON customers FOR EACH ROW
DECLARE
v_old_salary NUMBER;
v_new_salary NUMBER := :NEW.salary; BEGIN
IF INSERTING OR UPDATING THEN
v_old_salary := :OLD.salary;
DBMS_OUTPUT.PUT_LINE('Salary difference: ' || (v_new_salary - v_old_salary)); ELSIF DELETING THEN
DBMS_OUTPUT.PUT_LINE('Salary deleted: ' || :OLD.salary); END IF;
END;
/


Problem statements 24
Write PL/SQL block to update the Customer table and increase the salary of each customer by 500
and use the SQL%ROWCOUNTattribute to determine the number of rows affected.
 
DECLARE
v_num_rows NUMBER; BEGIN
-- Update the Customer table to increase the salary by 500 UPDATE Customer
SET salary = salary + 500;


-- Get the number of rows affected by the update v_num_rows := SQL%ROWCOUNT;

-- Display the number of rows affected
DBMS_OUTPUT.PUT_LINE('Number of rows updated: ' || v_num_rows); END;
/
